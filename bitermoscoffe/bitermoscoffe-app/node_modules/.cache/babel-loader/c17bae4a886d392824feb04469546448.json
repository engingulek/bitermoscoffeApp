{"ast":null,"code":"import { arrayIncludes } from './utils';\nexport const findClosestEnabledDate = ({\n  date,\n  disableFuture,\n  disablePast,\n  maxDate,\n  minDate,\n  shouldDisableDate,\n  utils\n}) => {\n  const today = utils.startOfDay(utils.date());\n\n  if (disablePast && utils.isBefore(minDate, today)) {\n    minDate = today;\n  }\n\n  if (disableFuture && utils.isAfter(maxDate, today)) {\n    maxDate = today;\n  }\n\n  let forward = date;\n  let backward = date;\n\n  if (utils.isBefore(date, minDate)) {\n    forward = utils.date(minDate);\n    backward = null;\n  }\n\n  if (utils.isAfter(date, maxDate)) {\n    if (backward) {\n      backward = utils.date(maxDate);\n    }\n\n    forward = null;\n  }\n\n  while (forward || backward) {\n    if (forward && utils.isAfter(forward, maxDate)) {\n      forward = null;\n    }\n\n    if (backward && utils.isBefore(backward, minDate)) {\n      backward = null;\n    }\n\n    if (forward) {\n      if (!shouldDisableDate(forward)) {\n        return forward;\n      }\n\n      forward = utils.addDays(forward, 1);\n    }\n\n    if (backward) {\n      if (!shouldDisableDate(backward)) {\n        return backward;\n      }\n\n      backward = utils.addDays(backward, -1);\n    }\n  } // fallback to today if no enabled days\n\n\n  return utils.date();\n};\nexport const isYearOnlyView = views => views.length === 1 && views[0] === 'year';\nexport const isYearAndMonthViews = views => views.length === 2 && arrayIncludes(views, 'month') && arrayIncludes(views, 'year');\nexport const getFormatAndMaskByViews = (views, utils) => {\n  if (isYearOnlyView(views)) {\n    return {\n      mask: '____',\n      inputFormat: utils.formats.year\n    };\n  }\n\n  if (isYearAndMonthViews(views)) {\n    return {\n      disableMaskedInput: true,\n      inputFormat: utils.formats.monthAndYear\n    };\n  }\n\n  return {\n    mask: '__/__/____',\n    inputFormat: utils.formats.keyboardDate\n  };\n};\nexport function parsePickerInputValue(utils, value) {\n  const parsedValue = utils.date(value);\n  return utils.isValid(parsedValue) ? parsedValue : null;\n}\nexport function parseRangeInputValue(utils, value = [null, null]) {\n  return value.map(date => !utils.isValid(date) || date === null ? null : utils.startOfDay(utils.date(date)));\n}\nexport const isRangeValid = (utils, range) => {\n  return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));\n};\nexport const isWithinRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isWithinRange(day, range);\n};\nexport const isStartOfRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);\n};\nexport const isEndOfRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);\n};\nexport const validateDate = (utils, value, {\n  disablePast,\n  disableFuture,\n  minDate,\n  maxDate,\n  shouldDisableDate\n}) => {\n  const now = utils.date();\n  const date = utils.date(value);\n\n  if (date === null) {\n    return null;\n  }\n\n  switch (true) {\n    case !utils.isValid(value):\n      return 'invalidDate';\n\n    case Boolean(shouldDisableDate && shouldDisableDate(date)):\n      return 'shouldDisableDate';\n\n    case Boolean(disableFuture && utils.isAfterDay(date, now)):\n      return 'disableFuture';\n\n    case Boolean(disablePast && utils.isBeforeDay(date, now)):\n      return 'disablePast';\n\n    case Boolean(minDate && utils.isBeforeDay(date, minDate)):\n      return 'minDate';\n\n    case Boolean(maxDate && utils.isAfterDay(date, maxDate)):\n      return 'maxDate';\n\n    default:\n      return null;\n  }\n};\nexport const validateDateRange = (utils, value, dateValidationProps) => {\n  const [start, end] = value; // for partial input\n\n  if (start === null || end === null) {\n    return [null, null];\n  }\n\n  const dateValidations = [validateDate(utils, start, dateValidationProps), validateDate(utils, end, dateValidationProps)];\n\n  if (dateValidations[0] || dateValidations[1]) {\n    return dateValidations;\n  }\n\n  if (!isRangeValid(utils, [utils.date(start), utils.date(end)])) {\n    return ['invalidRange', 'invalidRange'];\n  }\n\n  return [null, null];\n};","map":{"version":3,"sources":["/Users/engingulek/Desktop/bitermoscoffeApp/bitermoscoffe/bitermoscoffe-app/node_modules/@material-ui/lab/internal/pickers/date-utils.js"],"names":["arrayIncludes","findClosestEnabledDate","date","disableFuture","disablePast","maxDate","minDate","shouldDisableDate","utils","today","startOfDay","isBefore","isAfter","forward","backward","addDays","isYearOnlyView","views","length","isYearAndMonthViews","getFormatAndMaskByViews","mask","inputFormat","formats","year","disableMaskedInput","monthAndYear","keyboardDate","parsePickerInputValue","value","parsedValue","isValid","parseRangeInputValue","map","isRangeValid","range","Boolean","isWithinRange","day","isStartOfRange","isSameDay","isEndOfRange","validateDate","now","isAfterDay","isBeforeDay","validateDateRange","dateValidationProps","start","end","dateValidations"],"mappings":"AAAA,SAASA,aAAT,QAA8B,SAA9B;AACA,OAAO,MAAMC,sBAAsB,GAAG,CAAC;AACrCC,EAAAA,IADqC;AAErCC,EAAAA,aAFqC;AAGrCC,EAAAA,WAHqC;AAIrCC,EAAAA,OAJqC;AAKrCC,EAAAA,OALqC;AAMrCC,EAAAA,iBANqC;AAOrCC,EAAAA;AAPqC,CAAD,KAQhC;AACJ,QAAMC,KAAK,GAAGD,KAAK,CAACE,UAAN,CAAiBF,KAAK,CAACN,IAAN,EAAjB,CAAd;;AAEA,MAAIE,WAAW,IAAII,KAAK,CAACG,QAAN,CAAeL,OAAf,EAAwBG,KAAxB,CAAnB,EAAmD;AACjDH,IAAAA,OAAO,GAAGG,KAAV;AACD;;AAED,MAAIN,aAAa,IAAIK,KAAK,CAACI,OAAN,CAAcP,OAAd,EAAuBI,KAAvB,CAArB,EAAoD;AAClDJ,IAAAA,OAAO,GAAGI,KAAV;AACD;;AAED,MAAII,OAAO,GAAGX,IAAd;AACA,MAAIY,QAAQ,GAAGZ,IAAf;;AAEA,MAAIM,KAAK,CAACG,QAAN,CAAeT,IAAf,EAAqBI,OAArB,CAAJ,EAAmC;AACjCO,IAAAA,OAAO,GAAGL,KAAK,CAACN,IAAN,CAAWI,OAAX,CAAV;AACAQ,IAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,MAAIN,KAAK,CAACI,OAAN,CAAcV,IAAd,EAAoBG,OAApB,CAAJ,EAAkC;AAChC,QAAIS,QAAJ,EAAc;AACZA,MAAAA,QAAQ,GAAGN,KAAK,CAACN,IAAN,CAAWG,OAAX,CAAX;AACD;;AAEDQ,IAAAA,OAAO,GAAG,IAAV;AACD;;AAED,SAAOA,OAAO,IAAIC,QAAlB,EAA4B;AAC1B,QAAID,OAAO,IAAIL,KAAK,CAACI,OAAN,CAAcC,OAAd,EAAuBR,OAAvB,CAAf,EAAgD;AAC9CQ,MAAAA,OAAO,GAAG,IAAV;AACD;;AAED,QAAIC,QAAQ,IAAIN,KAAK,CAACG,QAAN,CAAeG,QAAf,EAAyBR,OAAzB,CAAhB,EAAmD;AACjDQ,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,QAAID,OAAJ,EAAa;AACX,UAAI,CAACN,iBAAiB,CAACM,OAAD,CAAtB,EAAiC;AAC/B,eAAOA,OAAP;AACD;;AAEDA,MAAAA,OAAO,GAAGL,KAAK,CAACO,OAAN,CAAcF,OAAd,EAAuB,CAAvB,CAAV;AACD;;AAED,QAAIC,QAAJ,EAAc;AACZ,UAAI,CAACP,iBAAiB,CAACO,QAAD,CAAtB,EAAkC;AAChC,eAAOA,QAAP;AACD;;AAEDA,MAAAA,QAAQ,GAAGN,KAAK,CAACO,OAAN,CAAcD,QAAd,EAAwB,CAAC,CAAzB,CAAX;AACD;AACF,GAnDG,CAmDF;;;AAGF,SAAON,KAAK,CAACN,IAAN,EAAP;AACD,CA/DM;AAgEP,OAAO,MAAMc,cAAc,GAAGC,KAAK,IAAIA,KAAK,CAACC,MAAN,KAAiB,CAAjB,IAAsBD,KAAK,CAAC,CAAD,CAAL,KAAa,MAAnE;AACP,OAAO,MAAME,mBAAmB,GAAGF,KAAK,IAAIA,KAAK,CAACC,MAAN,KAAiB,CAAjB,IAAsBlB,aAAa,CAACiB,KAAD,EAAQ,OAAR,CAAnC,IAAuDjB,aAAa,CAACiB,KAAD,EAAQ,MAAR,CAAzG;AACP,OAAO,MAAMG,uBAAuB,GAAG,CAACH,KAAD,EAAQT,KAAR,KAAkB;AACvD,MAAIQ,cAAc,CAACC,KAAD,CAAlB,EAA2B;AACzB,WAAO;AACLI,MAAAA,IAAI,EAAE,MADD;AAELC,MAAAA,WAAW,EAAEd,KAAK,CAACe,OAAN,CAAcC;AAFtB,KAAP;AAID;;AAED,MAAIL,mBAAmB,CAACF,KAAD,CAAvB,EAAgC;AAC9B,WAAO;AACLQ,MAAAA,kBAAkB,EAAE,IADf;AAELH,MAAAA,WAAW,EAAEd,KAAK,CAACe,OAAN,CAAcG;AAFtB,KAAP;AAID;;AAED,SAAO;AACLL,IAAAA,IAAI,EAAE,YADD;AAELC,IAAAA,WAAW,EAAEd,KAAK,CAACe,OAAN,CAAcI;AAFtB,GAAP;AAID,CAnBM;AAoBP,OAAO,SAASC,qBAAT,CAA+BpB,KAA/B,EAAsCqB,KAAtC,EAA6C;AAClD,QAAMC,WAAW,GAAGtB,KAAK,CAACN,IAAN,CAAW2B,KAAX,CAApB;AACA,SAAOrB,KAAK,CAACuB,OAAN,CAAcD,WAAd,IAA6BA,WAA7B,GAA2C,IAAlD;AACD;AACD,OAAO,SAASE,oBAAT,CAA8BxB,KAA9B,EAAqCqB,KAAK,GAAG,CAAC,IAAD,EAAO,IAAP,CAA7C,EAA2D;AAChE,SAAOA,KAAK,CAACI,GAAN,CAAU/B,IAAI,IAAI,CAACM,KAAK,CAACuB,OAAN,CAAc7B,IAAd,CAAD,IAAwBA,IAAI,KAAK,IAAjC,GAAwC,IAAxC,GAA+CM,KAAK,CAACE,UAAN,CAAiBF,KAAK,CAACN,IAAN,CAAWA,IAAX,CAAjB,CAAjE,CAAP;AACD;AACD,OAAO,MAAMgC,YAAY,GAAG,CAAC1B,KAAD,EAAQ2B,KAAR,KAAkB;AAC5C,SAAOC,OAAO,CAACD,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAd,IAAqBA,KAAK,CAAC,CAAD,CAA1B,IAAiC,CAAC3B,KAAK,CAACG,QAAN,CAAewB,KAAK,CAAC,CAAD,CAApB,EAAyBA,KAAK,CAAC,CAAD,CAA9B,CAAnC,CAAd;AACD,CAFM;AAGP,OAAO,MAAME,aAAa,GAAG,CAAC7B,KAAD,EAAQ8B,GAAR,EAAaH,KAAb,KAAuB;AAClD,SAAOD,YAAY,CAAC1B,KAAD,EAAQ2B,KAAR,CAAZ,IAA8B3B,KAAK,CAAC6B,aAAN,CAAoBC,GAApB,EAAyBH,KAAzB,CAArC;AACD,CAFM;AAGP,OAAO,MAAMI,cAAc,GAAG,CAAC/B,KAAD,EAAQ8B,GAAR,EAAaH,KAAb,KAAuB;AACnD,SAAOD,YAAY,CAAC1B,KAAD,EAAQ2B,KAAR,CAAZ,IAA8B3B,KAAK,CAACgC,SAAN,CAAgBF,GAAhB,EAAqBH,KAAK,CAAC,CAAD,CAA1B,CAArC;AACD,CAFM;AAGP,OAAO,MAAMM,YAAY,GAAG,CAACjC,KAAD,EAAQ8B,GAAR,EAAaH,KAAb,KAAuB;AACjD,SAAOD,YAAY,CAAC1B,KAAD,EAAQ2B,KAAR,CAAZ,IAA8B3B,KAAK,CAACgC,SAAN,CAAgBF,GAAhB,EAAqBH,KAAK,CAAC,CAAD,CAA1B,CAArC;AACD,CAFM;AAGP,OAAO,MAAMO,YAAY,GAAG,CAAClC,KAAD,EAAQqB,KAAR,EAAe;AACzCzB,EAAAA,WADyC;AAEzCD,EAAAA,aAFyC;AAGzCG,EAAAA,OAHyC;AAIzCD,EAAAA,OAJyC;AAKzCE,EAAAA;AALyC,CAAf,KAMtB;AACJ,QAAMoC,GAAG,GAAGnC,KAAK,CAACN,IAAN,EAAZ;AACA,QAAMA,IAAI,GAAGM,KAAK,CAACN,IAAN,CAAW2B,KAAX,CAAb;;AAEA,MAAI3B,IAAI,KAAK,IAAb,EAAmB;AACjB,WAAO,IAAP;AACD;;AAED,UAAQ,IAAR;AACE,SAAK,CAACM,KAAK,CAACuB,OAAN,CAAcF,KAAd,CAAN;AACE,aAAO,aAAP;;AAEF,SAAKO,OAAO,CAAC7B,iBAAiB,IAAIA,iBAAiB,CAACL,IAAD,CAAvC,CAAZ;AACE,aAAO,mBAAP;;AAEF,SAAKkC,OAAO,CAACjC,aAAa,IAAIK,KAAK,CAACoC,UAAN,CAAiB1C,IAAjB,EAAuByC,GAAvB,CAAlB,CAAZ;AACE,aAAO,eAAP;;AAEF,SAAKP,OAAO,CAAChC,WAAW,IAAII,KAAK,CAACqC,WAAN,CAAkB3C,IAAlB,EAAwByC,GAAxB,CAAhB,CAAZ;AACE,aAAO,aAAP;;AAEF,SAAKP,OAAO,CAAC9B,OAAO,IAAIE,KAAK,CAACqC,WAAN,CAAkB3C,IAAlB,EAAwBI,OAAxB,CAAZ,CAAZ;AACE,aAAO,SAAP;;AAEF,SAAK8B,OAAO,CAAC/B,OAAO,IAAIG,KAAK,CAACoC,UAAN,CAAiB1C,IAAjB,EAAuBG,OAAvB,CAAZ,CAAZ;AACE,aAAO,SAAP;;AAEF;AACE,aAAO,IAAP;AApBJ;AAsBD,CApCM;AAqCP,OAAO,MAAMyC,iBAAiB,GAAG,CAACtC,KAAD,EAAQqB,KAAR,EAAekB,mBAAf,KAAuC;AACtE,QAAM,CAACC,KAAD,EAAQC,GAAR,IAAepB,KAArB,CADsE,CAC1C;;AAE5B,MAAImB,KAAK,KAAK,IAAV,IAAkBC,GAAG,KAAK,IAA9B,EAAoC;AAClC,WAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACD;;AAED,QAAMC,eAAe,GAAG,CAACR,YAAY,CAAClC,KAAD,EAAQwC,KAAR,EAAeD,mBAAf,CAAb,EAAkDL,YAAY,CAAClC,KAAD,EAAQyC,GAAR,EAAaF,mBAAb,CAA9D,CAAxB;;AAEA,MAAIG,eAAe,CAAC,CAAD,CAAf,IAAsBA,eAAe,CAAC,CAAD,CAAzC,EAA8C;AAC5C,WAAOA,eAAP;AACD;;AAED,MAAI,CAAChB,YAAY,CAAC1B,KAAD,EAAQ,CAACA,KAAK,CAACN,IAAN,CAAW8C,KAAX,CAAD,EAAoBxC,KAAK,CAACN,IAAN,CAAW+C,GAAX,CAApB,CAAR,CAAjB,EAAgE;AAC9D,WAAO,CAAC,cAAD,EAAiB,cAAjB,CAAP;AACD;;AAED,SAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACD,CAlBM","sourcesContent":["import { arrayIncludes } from './utils';\nexport const findClosestEnabledDate = ({\n  date,\n  disableFuture,\n  disablePast,\n  maxDate,\n  minDate,\n  shouldDisableDate,\n  utils\n}) => {\n  const today = utils.startOfDay(utils.date());\n\n  if (disablePast && utils.isBefore(minDate, today)) {\n    minDate = today;\n  }\n\n  if (disableFuture && utils.isAfter(maxDate, today)) {\n    maxDate = today;\n  }\n\n  let forward = date;\n  let backward = date;\n\n  if (utils.isBefore(date, minDate)) {\n    forward = utils.date(minDate);\n    backward = null;\n  }\n\n  if (utils.isAfter(date, maxDate)) {\n    if (backward) {\n      backward = utils.date(maxDate);\n    }\n\n    forward = null;\n  }\n\n  while (forward || backward) {\n    if (forward && utils.isAfter(forward, maxDate)) {\n      forward = null;\n    }\n\n    if (backward && utils.isBefore(backward, minDate)) {\n      backward = null;\n    }\n\n    if (forward) {\n      if (!shouldDisableDate(forward)) {\n        return forward;\n      }\n\n      forward = utils.addDays(forward, 1);\n    }\n\n    if (backward) {\n      if (!shouldDisableDate(backward)) {\n        return backward;\n      }\n\n      backward = utils.addDays(backward, -1);\n    }\n  } // fallback to today if no enabled days\n\n\n  return utils.date();\n};\nexport const isYearOnlyView = views => views.length === 1 && views[0] === 'year';\nexport const isYearAndMonthViews = views => views.length === 2 && arrayIncludes(views, 'month') && arrayIncludes(views, 'year');\nexport const getFormatAndMaskByViews = (views, utils) => {\n  if (isYearOnlyView(views)) {\n    return {\n      mask: '____',\n      inputFormat: utils.formats.year\n    };\n  }\n\n  if (isYearAndMonthViews(views)) {\n    return {\n      disableMaskedInput: true,\n      inputFormat: utils.formats.monthAndYear\n    };\n  }\n\n  return {\n    mask: '__/__/____',\n    inputFormat: utils.formats.keyboardDate\n  };\n};\nexport function parsePickerInputValue(utils, value) {\n  const parsedValue = utils.date(value);\n  return utils.isValid(parsedValue) ? parsedValue : null;\n}\nexport function parseRangeInputValue(utils, value = [null, null]) {\n  return value.map(date => !utils.isValid(date) || date === null ? null : utils.startOfDay(utils.date(date)));\n}\nexport const isRangeValid = (utils, range) => {\n  return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));\n};\nexport const isWithinRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isWithinRange(day, range);\n};\nexport const isStartOfRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);\n};\nexport const isEndOfRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);\n};\nexport const validateDate = (utils, value, {\n  disablePast,\n  disableFuture,\n  minDate,\n  maxDate,\n  shouldDisableDate\n}) => {\n  const now = utils.date();\n  const date = utils.date(value);\n\n  if (date === null) {\n    return null;\n  }\n\n  switch (true) {\n    case !utils.isValid(value):\n      return 'invalidDate';\n\n    case Boolean(shouldDisableDate && shouldDisableDate(date)):\n      return 'shouldDisableDate';\n\n    case Boolean(disableFuture && utils.isAfterDay(date, now)):\n      return 'disableFuture';\n\n    case Boolean(disablePast && utils.isBeforeDay(date, now)):\n      return 'disablePast';\n\n    case Boolean(minDate && utils.isBeforeDay(date, minDate)):\n      return 'minDate';\n\n    case Boolean(maxDate && utils.isAfterDay(date, maxDate)):\n      return 'maxDate';\n\n    default:\n      return null;\n  }\n};\nexport const validateDateRange = (utils, value, dateValidationProps) => {\n  const [start, end] = value; // for partial input\n\n  if (start === null || end === null) {\n    return [null, null];\n  }\n\n  const dateValidations = [validateDate(utils, start, dateValidationProps), validateDate(utils, end, dateValidationProps)];\n\n  if (dateValidations[0] || dateValidations[1]) {\n    return dateValidations;\n  }\n\n  if (!isRangeValid(utils, [utils.date(start), utils.date(end)])) {\n    return ['invalidRange', 'invalidRange'];\n  }\n\n  return [null, null];\n};"]},"metadata":{},"sourceType":"module"}